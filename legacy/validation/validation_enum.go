// Code generated by go-enum
// DO NOT EDIT!

package validation

import (
	"fmt"
)

const (
	// NoDescription is a Description of type NoDescription
	NoDescription Description = iota
	// AnonymousOperationMustBeLonePerDocument is a Description of type AnonymousOperationMustBeLonePerDocument
	AnonymousOperationMustBeLonePerDocument
	// ArgumentMustBeUnique is a Description of type ArgumentMustBeUnique
	ArgumentMustBeUnique
	// ArgumentRequired is a Description of type ArgumentRequired
	ArgumentRequired
	// ArgumentValueTypeMismatch is a Description of type ArgumentValueTypeMismatch
	ArgumentValueTypeMismatch
	// DirectiveNotDefined is a Description of type DirectiveNotDefined
	DirectiveNotDefined
	// DirectiveLocationInvalid is a Description of type DirectiveLocationInvalid
	DirectiveLocationInvalid
	// DirectiveMustBeUniquePerLocation is a Description of type DirectiveMustBeUniquePerLocation
	DirectiveMustBeUniquePerLocation
	// FieldNameOrAliasMismatch is a Description of type FieldNameOrAliasMismatch
	FieldNameOrAliasMismatch
	// FieldSelectionsInvalid is a Description of type FieldSelectionsInvalid
	FieldSelectionsInvalid
	// FragmentNotDefined is a Description of type FragmentNotDefined
	FragmentNotDefined
	// FragmentSpreadCyclicReference is a Description of type FragmentSpreadCyclicReference
	FragmentSpreadCyclicReference
	// FragmentDefinitionOnLeafNode is a Description of type FragmentDefinitionOnLeafNode
	FragmentDefinitionOnLeafNode
	// FragmentRedeclared is a Description of type FragmentRedeclared
	FragmentRedeclared
	// FragmentDeclaredButNeverUsed is a Description of type FragmentDeclaredButNeverUsed
	FragmentDeclaredButNeverUsed
	// InputValueNotDefined is a Description of type InputValueNotDefined
	InputValueNotDefined
	// OperationNameMustBeUnique is a Description of type OperationNameMustBeUnique
	OperationNameMustBeUnique
	// RootTypeNotDefined is a Description of type RootTypeNotDefined
	RootTypeNotDefined
	// SelectionSetInvalid is a Description of type SelectionSetInvalid
	SelectionSetInvalid
	// SelectionSetResponseShapesCannotMerge is a Description of type SelectionSetResponseShapesCannotMerge
	SelectionSetResponseShapesCannotMerge
	// SubscriptionsMustHaveMaxOneRootField is a Description of type SubscriptionsMustHaveMaxOneRootField
	SubscriptionsMustHaveMaxOneRootField
	// TypeNotDefined is a Description of type TypeNotDefined
	TypeNotDefined
	// ValueInvalid is a Description of type ValueInvalid
	ValueInvalid
	// VariableMustBeUniquePerOperation is a Description of type VariableMustBeUniquePerOperation
	VariableMustBeUniquePerOperation
	// VariableMustBeValidInputType is a Description of type VariableMustBeValidInputType
	VariableMustBeValidInputType
	// VariableNotDefined is a Description of type VariableNotDefined
	VariableNotDefined
	// VariableDefinedButNotUsed is a Description of type VariableDefinedButNotUsed
	VariableDefinedButNotUsed
)

const _DescriptionName = "NoDescriptionAnonymousOperationMustBeLonePerDocumentArgumentMustBeUniqueArgumentRequiredArgumentValueTypeMismatchDirectiveNotDefinedDirectiveLocationInvalidDirectiveMustBeUniquePerLocationFieldNameOrAliasMismatchFieldSelectionsInvalidFragmentNotDefinedFragmentSpreadCyclicReferenceFragmentDefinitionOnLeafNodeFragmentRedeclaredFragmentDeclaredButNeverUsedInputValueNotDefinedOperationNameMustBeUniqueRootTypeNotDefinedSelectionSetInvalidSelectionSetResponseShapesCannotMergeSubscriptionsMustHaveMaxOneRootFieldTypeNotDefinedValueInvalidVariableMustBeUniquePerOperationVariableMustBeValidInputTypeVariableNotDefinedVariableDefinedButNotUsed"

var _DescriptionMap = map[Description]string{
	0:  _DescriptionName[0:13],
	1:  _DescriptionName[13:52],
	2:  _DescriptionName[52:72],
	3:  _DescriptionName[72:88],
	4:  _DescriptionName[88:113],
	5:  _DescriptionName[113:132],
	6:  _DescriptionName[132:156],
	7:  _DescriptionName[156:188],
	8:  _DescriptionName[188:212],
	9:  _DescriptionName[212:234],
	10: _DescriptionName[234:252],
	11: _DescriptionName[252:281],
	12: _DescriptionName[281:309],
	13: _DescriptionName[309:327],
	14: _DescriptionName[327:355],
	15: _DescriptionName[355:375],
	16: _DescriptionName[375:400],
	17: _DescriptionName[400:418],
	18: _DescriptionName[418:437],
	19: _DescriptionName[437:474],
	20: _DescriptionName[474:510],
	21: _DescriptionName[510:524],
	22: _DescriptionName[524:536],
	23: _DescriptionName[536:568],
	24: _DescriptionName[568:596],
	25: _DescriptionName[596:614],
	26: _DescriptionName[614:639],
}

// String implements the Stringer interface.
func (x Description) String() string {
	if str, ok := _DescriptionMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Description(%d)", x)
}

var _DescriptionValue = map[string]Description{
	_DescriptionName[0:13]:    0,
	_DescriptionName[13:52]:   1,
	_DescriptionName[52:72]:   2,
	_DescriptionName[72:88]:   3,
	_DescriptionName[88:113]:  4,
	_DescriptionName[113:132]: 5,
	_DescriptionName[132:156]: 6,
	_DescriptionName[156:188]: 7,
	_DescriptionName[188:212]: 8,
	_DescriptionName[212:234]: 9,
	_DescriptionName[234:252]: 10,
	_DescriptionName[252:281]: 11,
	_DescriptionName[281:309]: 12,
	_DescriptionName[309:327]: 13,
	_DescriptionName[327:355]: 14,
	_DescriptionName[355:375]: 15,
	_DescriptionName[375:400]: 16,
	_DescriptionName[400:418]: 17,
	_DescriptionName[418:437]: 18,
	_DescriptionName[437:474]: 19,
	_DescriptionName[474:510]: 20,
	_DescriptionName[510:524]: 21,
	_DescriptionName[524:536]: 22,
	_DescriptionName[536:568]: 23,
	_DescriptionName[568:596]: 24,
	_DescriptionName[596:614]: 25,
	_DescriptionName[614:639]: 26,
}

// ParseDescription attempts to convert a string to a Description
func ParseDescription(name string) (Description, error) {
	if x, ok := _DescriptionValue[name]; ok {
		return x, nil
	}
	return Description(0), fmt.Errorf("%s is not a valid Description", name)
}

const (
	// NoRule is a RuleName of type NoRule
	NoRule RuleName = iota
	// ArgumentUniqueness is a RuleName of type ArgumentUniqueness
	ArgumentUniqueness
	// DirectivesAreDefined is a RuleName of type DirectivesAreDefined
	DirectivesAreDefined
	// DirectivesAreInValidLocations is a RuleName of type DirectivesAreInValidLocations
	DirectivesAreInValidLocations
	// DirectivesAreUniquePerLocation is a RuleName of type DirectivesAreUniquePerLocation
	DirectivesAreUniquePerLocation
	// DirectivesHaveRequiredArguments is a RuleName of type DirectivesHaveRequiredArguments
	DirectivesHaveRequiredArguments
	// DirectivesArgumentsAreDefined is a RuleName of type DirectivesArgumentsAreDefined
	DirectivesArgumentsAreDefined
	// DirectiveArgumentsAreConstants is a RuleName of type DirectiveArgumentsAreConstants
	DirectiveArgumentsAreConstants
	// DirectiveDefinitionArgumentsAreConstants is a RuleName of type DirectiveDefinitionArgumentsAreConstants
	DirectiveDefinitionArgumentsAreConstants
	// DirectiveDefinitionDefaultValuesAreOfCorrectType is a RuleName of type DirectiveDefinitionDefaultValuesAreOfCorrectType
	DirectiveDefinitionDefaultValuesAreOfCorrectType
	// FieldSelectionMerging is a RuleName of type FieldSelectionMerging
	FieldSelectionMerging
	// FieldSelections is a RuleName of type FieldSelections
	FieldSelections
	// Fragments is a RuleName of type Fragments
	Fragments
	// LoneAnonymousOperation is a RuleName of type LoneAnonymousOperation
	LoneAnonymousOperation
	// OperationNameUniqueness is a RuleName of type OperationNameUniqueness
	OperationNameUniqueness
	// RequiredArguments is a RuleName of type RequiredArguments
	RequiredArguments
	// SubscriptionSingleRootField is a RuleName of type SubscriptionSingleRootField
	SubscriptionSingleRootField
	// ValidArguments is a RuleName of type ValidArguments
	ValidArguments
	// Values is a RuleName of type Values
	Values
	// VariableUniqueness is a RuleName of type VariableUniqueness
	VariableUniqueness
	// VariablesAreInputTypes is a RuleName of type VariablesAreInputTypes
	VariablesAreInputTypes
	// AllVariablesUsed is a RuleName of type AllVariablesUsed
	AllVariablesUsed
	// AllVariableUsesDefined is a RuleName of type AllVariableUsesDefined
	AllVariableUsesDefined
)

const _RuleNameName = "NoRuleArgumentUniquenessDirectivesAreDefinedDirectivesAreInValidLocationsDirectivesAreUniquePerLocationDirectivesHaveRequiredArgumentsDirectivesArgumentsAreDefinedDirectiveArgumentsAreConstantsDirectiveDefinitionArgumentsAreConstantsDirectiveDefinitionDefaultValuesAreOfCorrectTypeFieldSelectionMergingFieldSelectionsFragmentsLoneAnonymousOperationOperationNameUniquenessRequiredArgumentsSubscriptionSingleRootFieldValidArgumentsValuesVariableUniquenessVariablesAreInputTypesAllVariablesUsedAllVariableUsesDefined"

var _RuleNameMap = map[RuleName]string{
	0:  _RuleNameName[0:6],
	1:  _RuleNameName[6:24],
	2:  _RuleNameName[24:44],
	3:  _RuleNameName[44:73],
	4:  _RuleNameName[73:103],
	5:  _RuleNameName[103:134],
	6:  _RuleNameName[134:163],
	7:  _RuleNameName[163:193],
	8:  _RuleNameName[193:233],
	9:  _RuleNameName[233:281],
	10: _RuleNameName[281:302],
	11: _RuleNameName[302:317],
	12: _RuleNameName[317:326],
	13: _RuleNameName[326:348],
	14: _RuleNameName[348:371],
	15: _RuleNameName[371:388],
	16: _RuleNameName[388:415],
	17: _RuleNameName[415:429],
	18: _RuleNameName[429:435],
	19: _RuleNameName[435:453],
	20: _RuleNameName[453:475],
	21: _RuleNameName[475:491],
	22: _RuleNameName[491:513],
}

// String implements the Stringer interface.
func (x RuleName) String() string {
	if str, ok := _RuleNameMap[x]; ok {
		return str
	}
	return fmt.Sprintf("RuleName(%d)", x)
}

var _RuleNameValue = map[string]RuleName{
	_RuleNameName[0:6]:     0,
	_RuleNameName[6:24]:    1,
	_RuleNameName[24:44]:   2,
	_RuleNameName[44:73]:   3,
	_RuleNameName[73:103]:  4,
	_RuleNameName[103:134]: 5,
	_RuleNameName[134:163]: 6,
	_RuleNameName[163:193]: 7,
	_RuleNameName[193:233]: 8,
	_RuleNameName[233:281]: 9,
	_RuleNameName[281:302]: 10,
	_RuleNameName[302:317]: 11,
	_RuleNameName[317:326]: 12,
	_RuleNameName[326:348]: 13,
	_RuleNameName[348:371]: 14,
	_RuleNameName[371:388]: 15,
	_RuleNameName[388:415]: 16,
	_RuleNameName[415:429]: 17,
	_RuleNameName[429:435]: 18,
	_RuleNameName[435:453]: 19,
	_RuleNameName[453:475]: 20,
	_RuleNameName[475:491]: 21,
	_RuleNameName[491:513]: 22,
}

// ParseRuleName attempts to convert a string to a RuleName
func ParseRuleName(name string) (RuleName, error) {
	if x, ok := _RuleNameValue[name]; ok {
		return x, nil
	}
	return RuleName(0), fmt.Errorf("%s is not a valid RuleName", name)
}
