// Code generated by go-enum
// DO NOT EDIT!

package validation

import (
	"fmt"
)

const (
	// NoDescription is a Description of type NoDescription
	NoDescription Description = iota
	// AnonymousOperationMustBeLonePerDocument is a Description of type AnonymousOperationMustBeLonePerDocument
	AnonymousOperationMustBeLonePerDocument
	// ArgumentMustBeUnique is a Description of type ArgumentMustBeUnique
	ArgumentMustBeUnique
	// ArgumentRequired is a Description of type ArgumentRequired
	ArgumentRequired
	// DirectiveNotDefined is a Description of type DirectiveNotDefined
	DirectiveNotDefined
	// DirectiveLocationInvalid is a Description of type DirectiveLocationInvalid
	DirectiveLocationInvalid
	// DirectiveMustBeUniquePerLocation is a Description of type DirectiveMustBeUniquePerLocation
	DirectiveMustBeUniquePerLocation
	// FieldNameOrAliasMismatch is a Description of type FieldNameOrAliasMismatch
	FieldNameOrAliasMismatch
	// FieldSelectionsInvalid is a Description of type FieldSelectionsInvalid
	FieldSelectionsInvalid
	// FragmentNotDefined is a Description of type FragmentNotDefined
	FragmentNotDefined
	// FragmentSpreadCyclicReference is a Description of type FragmentSpreadCyclicReference
	FragmentSpreadCyclicReference
	// FragmentDefinitionOnLeafNode is a Description of type FragmentDefinitionOnLeafNode
	FragmentDefinitionOnLeafNode
	// FragmentRedeclared is a Description of type FragmentRedeclared
	FragmentRedeclared
	// FragmentDeclaredButNeverUsed is a Description of type FragmentDeclaredButNeverUsed
	FragmentDeclaredButNeverUsed
	// InputValueNotDefined is a Description of type InputValueNotDefined
	InputValueNotDefined
	// OperationNameMustBeUnique is a Description of type OperationNameMustBeUnique
	OperationNameMustBeUnique
	// RootTypeNotDefined is a Description of type RootTypeNotDefined
	RootTypeNotDefined
	// SelectionSetInvalid is a Description of type SelectionSetInvalid
	SelectionSetInvalid
	// SelectionSetResponseShapesCannotMerge is a Description of type SelectionSetResponseShapesCannotMerge
	SelectionSetResponseShapesCannotMerge
	// SubscriptionsMustHaveMaxOneRootField is a Description of type SubscriptionsMustHaveMaxOneRootField
	SubscriptionsMustHaveMaxOneRootField
	// TypeNotDefined is a Description of type TypeNotDefined
	TypeNotDefined
	// ValueInvalid is a Description of type ValueInvalid
	ValueInvalid
	// VariableMustBeUniquePerOperation is a Description of type VariableMustBeUniquePerOperation
	VariableMustBeUniquePerOperation
	// VariableMustBeValidInputType is a Description of type VariableMustBeValidInputType
	VariableMustBeValidInputType
	// VariableNotDefined is a Description of type VariableNotDefined
	VariableNotDefined
	// VariableDefinedButNotUsed is a Description of type VariableDefinedButNotUsed
	VariableDefinedButNotUsed
)

const _DescriptionName = "NoDescriptionAnonymousOperationMustBeLonePerDocumentArgumentMustBeUniqueArgumentRequiredDirectiveNotDefinedDirectiveLocationInvalidDirectiveMustBeUniquePerLocationFieldNameOrAliasMismatchFieldSelectionsInvalidFragmentNotDefinedFragmentSpreadCyclicReferenceFragmentDefinitionOnLeafNodeFragmentRedeclaredFragmentDeclaredButNeverUsedInputValueNotDefinedOperationNameMustBeUniqueRootTypeNotDefinedSelectionSetInvalidSelectionSetResponseShapesCannotMergeSubscriptionsMustHaveMaxOneRootFieldTypeNotDefinedValueInvalidVariableMustBeUniquePerOperationVariableMustBeValidInputTypeVariableNotDefinedVariableDefinedButNotUsed"

var _DescriptionMap = map[Description]string{
	0:  _DescriptionName[0:13],
	1:  _DescriptionName[13:52],
	2:  _DescriptionName[52:72],
	3:  _DescriptionName[72:88],
	4:  _DescriptionName[88:107],
	5:  _DescriptionName[107:131],
	6:  _DescriptionName[131:163],
	7:  _DescriptionName[163:187],
	8:  _DescriptionName[187:209],
	9:  _DescriptionName[209:227],
	10: _DescriptionName[227:256],
	11: _DescriptionName[256:284],
	12: _DescriptionName[284:302],
	13: _DescriptionName[302:330],
	14: _DescriptionName[330:350],
	15: _DescriptionName[350:375],
	16: _DescriptionName[375:393],
	17: _DescriptionName[393:412],
	18: _DescriptionName[412:449],
	19: _DescriptionName[449:485],
	20: _DescriptionName[485:499],
	21: _DescriptionName[499:511],
	22: _DescriptionName[511:543],
	23: _DescriptionName[543:571],
	24: _DescriptionName[571:589],
	25: _DescriptionName[589:614],
}

// String implements the Stringer interface.
func (x Description) String() string {
	if str, ok := _DescriptionMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Description(%d)", x)
}

var _DescriptionValue = map[string]Description{
	_DescriptionName[0:13]:    0,
	_DescriptionName[13:52]:   1,
	_DescriptionName[52:72]:   2,
	_DescriptionName[72:88]:   3,
	_DescriptionName[88:107]:  4,
	_DescriptionName[107:131]: 5,
	_DescriptionName[131:163]: 6,
	_DescriptionName[163:187]: 7,
	_DescriptionName[187:209]: 8,
	_DescriptionName[209:227]: 9,
	_DescriptionName[227:256]: 10,
	_DescriptionName[256:284]: 11,
	_DescriptionName[284:302]: 12,
	_DescriptionName[302:330]: 13,
	_DescriptionName[330:350]: 14,
	_DescriptionName[350:375]: 15,
	_DescriptionName[375:393]: 16,
	_DescriptionName[393:412]: 17,
	_DescriptionName[412:449]: 18,
	_DescriptionName[449:485]: 19,
	_DescriptionName[485:499]: 20,
	_DescriptionName[499:511]: 21,
	_DescriptionName[511:543]: 22,
	_DescriptionName[543:571]: 23,
	_DescriptionName[571:589]: 24,
	_DescriptionName[589:614]: 25,
}

// ParseDescription attempts to convert a string to a Description
func ParseDescription(name string) (Description, error) {
	if x, ok := _DescriptionValue[name]; ok {
		return x, nil
	}
	return Description(0), fmt.Errorf("%s is not a valid Description", name)
}

const (
	// NoRule is a RuleName of type NoRule
	NoRule RuleName = iota
	// ArgumentUniqueness is a RuleName of type ArgumentUniqueness
	ArgumentUniqueness
	// DirectivesAreDefined is a RuleName of type DirectivesAreDefined
	DirectivesAreDefined
	// DirectivesAreInValidLocations is a RuleName of type DirectivesAreInValidLocations
	DirectivesAreInValidLocations
	// DirectivesAreUniquePerLocation is a RuleName of type DirectivesAreUniquePerLocation
	DirectivesAreUniquePerLocation
	// DirectivesHaveRequiredArguments is a RuleName of type DirectivesHaveRequiredArguments
	DirectivesHaveRequiredArguments
	// FieldSelectionMerging is a RuleName of type FieldSelectionMerging
	FieldSelectionMerging
	// FieldSelections is a RuleName of type FieldSelections
	FieldSelections
	// Fragments is a RuleName of type Fragments
	Fragments
	// LoneAnonymousOperation is a RuleName of type LoneAnonymousOperation
	LoneAnonymousOperation
	// OperationNameUniqueness is a RuleName of type OperationNameUniqueness
	OperationNameUniqueness
	// RequiredArguments is a RuleName of type RequiredArguments
	RequiredArguments
	// SubscriptionSingleRootField is a RuleName of type SubscriptionSingleRootField
	SubscriptionSingleRootField
	// ValidArguments is a RuleName of type ValidArguments
	ValidArguments
	// Values is a RuleName of type Values
	Values
	// VariableUniqueness is a RuleName of type VariableUniqueness
	VariableUniqueness
	// VariablesAreInputTypes is a RuleName of type VariablesAreInputTypes
	VariablesAreInputTypes
	// AllVariablesUsed is a RuleName of type AllVariablesUsed
	AllVariablesUsed
	// AllVariableUsesDefined is a RuleName of type AllVariableUsesDefined
	AllVariableUsesDefined
)

const _RuleNameName = "NoRuleArgumentUniquenessDirectivesAreDefinedDirectivesAreInValidLocationsDirectivesAreUniquePerLocationDirectivesHaveRequiredArgumentsFieldSelectionMergingFieldSelectionsFragmentsLoneAnonymousOperationOperationNameUniquenessRequiredArgumentsSubscriptionSingleRootFieldValidArgumentsValuesVariableUniquenessVariablesAreInputTypesAllVariablesUsedAllVariableUsesDefined"

var _RuleNameMap = map[RuleName]string{
	0:  _RuleNameName[0:6],
	1:  _RuleNameName[6:24],
	2:  _RuleNameName[24:44],
	3:  _RuleNameName[44:73],
	4:  _RuleNameName[73:103],
	5:  _RuleNameName[103:134],
	6:  _RuleNameName[134:155],
	7:  _RuleNameName[155:170],
	8:  _RuleNameName[170:179],
	9:  _RuleNameName[179:201],
	10: _RuleNameName[201:224],
	11: _RuleNameName[224:241],
	12: _RuleNameName[241:268],
	13: _RuleNameName[268:282],
	14: _RuleNameName[282:288],
	15: _RuleNameName[288:306],
	16: _RuleNameName[306:328],
	17: _RuleNameName[328:344],
	18: _RuleNameName[344:366],
}

// String implements the Stringer interface.
func (x RuleName) String() string {
	if str, ok := _RuleNameMap[x]; ok {
		return str
	}
	return fmt.Sprintf("RuleName(%d)", x)
}

var _RuleNameValue = map[string]RuleName{
	_RuleNameName[0:6]:     0,
	_RuleNameName[6:24]:    1,
	_RuleNameName[24:44]:   2,
	_RuleNameName[44:73]:   3,
	_RuleNameName[73:103]:  4,
	_RuleNameName[103:134]: 5,
	_RuleNameName[134:155]: 6,
	_RuleNameName[155:170]: 7,
	_RuleNameName[170:179]: 8,
	_RuleNameName[179:201]: 9,
	_RuleNameName[201:224]: 10,
	_RuleNameName[224:241]: 11,
	_RuleNameName[241:268]: 12,
	_RuleNameName[268:282]: 13,
	_RuleNameName[282:288]: 14,
	_RuleNameName[288:306]: 15,
	_RuleNameName[306:328]: 16,
	_RuleNameName[328:344]: 17,
	_RuleNameName[344:366]: 18,
}

// ParseRuleName attempts to convert a string to a RuleName
func ParseRuleName(name string) (RuleName, error) {
	if x, ok := _RuleNameValue[name]; ok {
		return x, nil
	}
	return RuleName(0), fmt.Errorf("%s is not a valid RuleName", name)
}
