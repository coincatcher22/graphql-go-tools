// Code generated by go-enum
// DO NOT EDIT!

package validation

import (
	"fmt"
)

const (
	// NoDescription is a Description of type NoDescription
	NoDescription Description = iota
	// AnonymousOperationMustBeLonePerDocument is a Description of type AnonymousOperationMustBeLonePerDocument
	AnonymousOperationMustBeLonePerDocument
	// ArgumentNotDefined is a Description of type ArgumentNotDefined
	ArgumentNotDefined
	// ArgumentMustBeUnique is a Description of type ArgumentMustBeUnique
	ArgumentMustBeUnique
	// ArgumentRequired is a Description of type ArgumentRequired
	ArgumentRequired
	// ArgumentsDefinitionMissing is a Description of type ArgumentsDefinitionMissing
	ArgumentsDefinitionMissing
	// ArgumentMismatch is a Description of type ArgumentMismatch
	ArgumentMismatch
	// DirectiveNotDefined is a Description of type DirectiveNotDefined
	DirectiveNotDefined
	// DirectiveLocationInvalid is a Description of type DirectiveLocationInvalid
	DirectiveLocationInvalid
	// DirectiveMustBeUniquePerLocation is a Description of type DirectiveMustBeUniquePerLocation
	DirectiveMustBeUniquePerLocation
	// FieldNameOrAliasMismatch is a Description of type FieldNameOrAliasMismatch
	FieldNameOrAliasMismatch
	// FieldSelectionsInvalid is a Description of type FieldSelectionsInvalid
	FieldSelectionsInvalid
	// FragmentNotDefined is a Description of type FragmentNotDefined
	FragmentNotDefined
	// FragmentSpreadCyclicReference is a Description of type FragmentSpreadCyclicReference
	FragmentSpreadCyclicReference
	// FragmentDefinitionOnLeafNode is a Description of type FragmentDefinitionOnLeafNode
	FragmentDefinitionOnLeafNode
	// FragmentRedeclared is a Description of type FragmentRedeclared
	FragmentRedeclared
	// FragmentDeclaredButNeverUsed is a Description of type FragmentDeclaredButNeverUsed
	FragmentDeclaredButNeverUsed
	// InlineFragmentOnLeafNode is a Description of type InlineFragmentOnLeafNode
	InlineFragmentOnLeafNode
	// InputValueNotDefined is a Description of type InputValueNotDefined
	InputValueNotDefined
	// MustHaveTypeCondition is a Description of type MustHaveTypeCondition
	MustHaveTypeCondition
	// MustHaveNamedTypeCondition is a Description of type MustHaveNamedTypeCondition
	MustHaveNamedTypeCondition
	// OperationNameMustBeUnique is a Description of type OperationNameMustBeUnique
	OperationNameMustBeUnique
	// QueryObjectTypeNotDefined is a Description of type QueryObjectTypeNotDefined
	QueryObjectTypeNotDefined
	// RootTypeNotDefined is a Description of type RootTypeNotDefined
	RootTypeNotDefined
	// SelectionSetInvalid is a Description of type SelectionSetInvalid
	SelectionSetInvalid
	// SelectionSetResponseShapesCannotMerge is a Description of type SelectionSetResponseShapesCannotMerge
	SelectionSetResponseShapesCannotMerge
	// SubscriptionsMustHaveMaxOneRootField is a Description of type SubscriptionsMustHaveMaxOneRootField
	SubscriptionsMustHaveMaxOneRootField
	// TypeNotDefined is a Description of type TypeNotDefined
	TypeNotDefined
	// ValueInvalid is a Description of type ValueInvalid
	ValueInvalid
	// VariableMustBeUniquePerOperation is a Description of type VariableMustBeUniquePerOperation
	VariableMustBeUniquePerOperation
	// VariableMustBeValidInputType is a Description of type VariableMustBeValidInputType
	VariableMustBeValidInputType
	// VariableNotDefined is a Description of type VariableNotDefined
	VariableNotDefined
	// VariableDefinedButNotUsed is a Description of type VariableDefinedButNotUsed
	VariableDefinedButNotUsed
)

const _DescriptionName = "NoDescriptionAnonymousOperationMustBeLonePerDocumentArgumentNotDefinedArgumentMustBeUniqueArgumentRequiredArgumentsDefinitionMissingArgumentMismatchDirectiveNotDefinedDirectiveLocationInvalidDirectiveMustBeUniquePerLocationFieldNameOrAliasMismatchFieldSelectionsInvalidFragmentNotDefinedFragmentSpreadCyclicReferenceFragmentDefinitionOnLeafNodeFragmentRedeclaredFragmentDeclaredButNeverUsedInlineFragmentOnLeafNodeInputValueNotDefinedMustHaveTypeConditionMustHaveNamedTypeConditionOperationNameMustBeUniqueQueryObjectTypeNotDefinedRootTypeNotDefinedSelectionSetInvalidSelectionSetResponseShapesCannotMergeSubscriptionsMustHaveMaxOneRootFieldTypeNotDefinedValueInvalidVariableMustBeUniquePerOperationVariableMustBeValidInputTypeVariableNotDefinedVariableDefinedButNotUsed"

var _DescriptionMap = map[Description]string{
	0:  _DescriptionName[0:13],
	1:  _DescriptionName[13:52],
	2:  _DescriptionName[52:70],
	3:  _DescriptionName[70:90],
	4:  _DescriptionName[90:106],
	5:  _DescriptionName[106:132],
	6:  _DescriptionName[132:148],
	7:  _DescriptionName[148:167],
	8:  _DescriptionName[167:191],
	9:  _DescriptionName[191:223],
	10: _DescriptionName[223:247],
	11: _DescriptionName[247:269],
	12: _DescriptionName[269:287],
	13: _DescriptionName[287:316],
	14: _DescriptionName[316:344],
	15: _DescriptionName[344:362],
	16: _DescriptionName[362:390],
	17: _DescriptionName[390:414],
	18: _DescriptionName[414:434],
	19: _DescriptionName[434:455],
	20: _DescriptionName[455:481],
	21: _DescriptionName[481:506],
	22: _DescriptionName[506:531],
	23: _DescriptionName[531:549],
	24: _DescriptionName[549:568],
	25: _DescriptionName[568:605],
	26: _DescriptionName[605:641],
	27: _DescriptionName[641:655],
	28: _DescriptionName[655:667],
	29: _DescriptionName[667:699],
	30: _DescriptionName[699:727],
	31: _DescriptionName[727:745],
	32: _DescriptionName[745:770],
}

// String implements the Stringer interface.
func (x Description) String() string {
	if str, ok := _DescriptionMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Description(%d)", x)
}

var _DescriptionValue = map[string]Description{
	_DescriptionName[0:13]:    0,
	_DescriptionName[13:52]:   1,
	_DescriptionName[52:70]:   2,
	_DescriptionName[70:90]:   3,
	_DescriptionName[90:106]:  4,
	_DescriptionName[106:132]: 5,
	_DescriptionName[132:148]: 6,
	_DescriptionName[148:167]: 7,
	_DescriptionName[167:191]: 8,
	_DescriptionName[191:223]: 9,
	_DescriptionName[223:247]: 10,
	_DescriptionName[247:269]: 11,
	_DescriptionName[269:287]: 12,
	_DescriptionName[287:316]: 13,
	_DescriptionName[316:344]: 14,
	_DescriptionName[344:362]: 15,
	_DescriptionName[362:390]: 16,
	_DescriptionName[390:414]: 17,
	_DescriptionName[414:434]: 18,
	_DescriptionName[434:455]: 19,
	_DescriptionName[455:481]: 20,
	_DescriptionName[481:506]: 21,
	_DescriptionName[506:531]: 22,
	_DescriptionName[531:549]: 23,
	_DescriptionName[549:568]: 24,
	_DescriptionName[568:605]: 25,
	_DescriptionName[605:641]: 26,
	_DescriptionName[641:655]: 27,
	_DescriptionName[655:667]: 28,
	_DescriptionName[667:699]: 29,
	_DescriptionName[699:727]: 30,
	_DescriptionName[727:745]: 31,
	_DescriptionName[745:770]: 32,
}

// ParseDescription attempts to convert a string to a Description
func ParseDescription(name string) (Description, error) {
	if x, ok := _DescriptionValue[name]; ok {
		return x, nil
	}
	return Description(0), fmt.Errorf("%s is not a valid Description", name)
}

const (
	// NoRule is a RuleName of type NoRule
	NoRule RuleName = iota
	// ArgumentUniqueness is a RuleName of type ArgumentUniqueness
	ArgumentUniqueness
	// DirectivesAreDefined is a RuleName of type DirectivesAreDefined
	DirectivesAreDefined
	// DirectivesAreInValidLocations is a RuleName of type DirectivesAreInValidLocations
	DirectivesAreInValidLocations
	// DirectivesAreUniquePerLocation is a RuleName of type DirectivesAreUniquePerLocation
	DirectivesAreUniquePerLocation
	// FieldSelectionMerging is a RuleName of type FieldSelectionMerging
	FieldSelectionMerging
	// FieldSelections is a RuleName of type FieldSelections
	FieldSelections
	// Fragments is a RuleName of type Fragments
	Fragments
	// LoneAnonymousOperation is a RuleName of type LoneAnonymousOperation
	LoneAnonymousOperation
	// OperationNameUniqueness is a RuleName of type OperationNameUniqueness
	OperationNameUniqueness
	// RequiredArguments is a RuleName of type RequiredArguments
	RequiredArguments
	// SubscriptionSingleRootField is a RuleName of type SubscriptionSingleRootField
	SubscriptionSingleRootField
	// ValidArguments is a RuleName of type ValidArguments
	ValidArguments
	// Values is a RuleName of type Values
	Values
	// VariableUniqueness is a RuleName of type VariableUniqueness
	VariableUniqueness
	// VariablesAreInputTypes is a RuleName of type VariablesAreInputTypes
	VariablesAreInputTypes
	// AllVariablesUsed is a RuleName of type AllVariablesUsed
	AllVariablesUsed
	// AllVariableUsesDefined is a RuleName of type AllVariableUsesDefined
	AllVariableUsesDefined
)

const _RuleNameName = "NoRuleArgumentUniquenessDirectivesAreDefinedDirectivesAreInValidLocationsDirectivesAreUniquePerLocationFieldSelectionMergingFieldSelectionsFragmentsLoneAnonymousOperationOperationNameUniquenessRequiredArgumentsSubscriptionSingleRootFieldValidArgumentsValuesVariableUniquenessVariablesAreInputTypesAllVariablesUsedAllVariableUsesDefined"

var _RuleNameMap = map[RuleName]string{
	0:  _RuleNameName[0:6],
	1:  _RuleNameName[6:24],
	2:  _RuleNameName[24:44],
	3:  _RuleNameName[44:73],
	4:  _RuleNameName[73:103],
	5:  _RuleNameName[103:124],
	6:  _RuleNameName[124:139],
	7:  _RuleNameName[139:148],
	8:  _RuleNameName[148:170],
	9:  _RuleNameName[170:193],
	10: _RuleNameName[193:210],
	11: _RuleNameName[210:237],
	12: _RuleNameName[237:251],
	13: _RuleNameName[251:257],
	14: _RuleNameName[257:275],
	15: _RuleNameName[275:297],
	16: _RuleNameName[297:313],
	17: _RuleNameName[313:335],
}

// String implements the Stringer interface.
func (x RuleName) String() string {
	if str, ok := _RuleNameMap[x]; ok {
		return str
	}
	return fmt.Sprintf("RuleName(%d)", x)
}

var _RuleNameValue = map[string]RuleName{
	_RuleNameName[0:6]:     0,
	_RuleNameName[6:24]:    1,
	_RuleNameName[24:44]:   2,
	_RuleNameName[44:73]:   3,
	_RuleNameName[73:103]:  4,
	_RuleNameName[103:124]: 5,
	_RuleNameName[124:139]: 6,
	_RuleNameName[139:148]: 7,
	_RuleNameName[148:170]: 8,
	_RuleNameName[170:193]: 9,
	_RuleNameName[193:210]: 10,
	_RuleNameName[210:237]: 11,
	_RuleNameName[237:251]: 12,
	_RuleNameName[251:257]: 13,
	_RuleNameName[257:275]: 14,
	_RuleNameName[275:297]: 15,
	_RuleNameName[297:313]: 16,
	_RuleNameName[313:335]: 17,
}

// ParseRuleName attempts to convert a string to a RuleName
func ParseRuleName(name string) (RuleName, error) {
	if x, ok := _RuleNameValue[name]; ok {
		return x, nil
	}
	return RuleName(0), fmt.Errorf("%s is not a valid RuleName", name)
}
