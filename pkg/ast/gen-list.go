// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package ast

import "github.com/jensneuse/graphql-go-tools/pkg/lexing/position"

type DirectiveList struct {
	Open          position.Position
	Close         position.Position
	current       Directive
	currentRef    int
	nextRef       int
	isInitialized bool
}

type DirectiveGetter interface {
	GetDirective(ref int) (node Directive, nextRef int)
}

func NewDirectiveList(first int) DirectiveList {
	nodeList := DirectiveList{}
	nodeList.SetFirst(first)
	return nodeList
}

func (n *DirectiveList) SetFirst(first int) {
	n.nextRef = first
	n.isInitialized = first != -1
}

func (n *DirectiveList) HasNext() bool {
	return n.isInitialized && n.nextRef != -1
}

func (n *DirectiveList) Next(getter DirectiveGetter) bool {
	if !n.isInitialized || n.nextRef == -1 {
		return false
	}
	n.currentRef = n.nextRef
	n.current, n.nextRef = getter.GetDirective(n.nextRef)
	return true
}

func (n *DirectiveList) Value() (Directive, int) {
	return n.current, n.currentRef
}

type FieldDefinitionList struct {
	Open          position.Position
	Close         position.Position
	current       FieldDefinition
	currentRef    int
	nextRef       int
	isInitialized bool
}

type FieldDefinitionGetter interface {
	GetFieldDefinition(ref int) (node FieldDefinition, nextRef int)
}

func NewFieldDefinitionList(first int) FieldDefinitionList {
	nodeList := FieldDefinitionList{}
	nodeList.SetFirst(first)
	return nodeList
}

func (n *FieldDefinitionList) SetFirst(first int) {
	n.nextRef = first
	n.isInitialized = first != -1
}

func (n *FieldDefinitionList) HasNext() bool {
	return n.isInitialized && n.nextRef != -1
}

func (n *FieldDefinitionList) Next(getter FieldDefinitionGetter) bool {
	if !n.isInitialized || n.nextRef == -1 {
		return false
	}
	n.currentRef = n.nextRef
	n.current, n.nextRef = getter.GetFieldDefinition(n.nextRef)
	return true
}

func (n *FieldDefinitionList) Value() (FieldDefinition, int) {
	return n.current, n.currentRef
}

type RootOperationTypeDefinitionList struct {
	Open          position.Position
	Close         position.Position
	current       RootOperationTypeDefinition
	currentRef    int
	nextRef       int
	isInitialized bool
}

type RootOperationTypeDefinitionGetter interface {
	GetRootOperationTypeDefinition(ref int) (node RootOperationTypeDefinition, nextRef int)
}

func NewRootOperationTypeDefinitionList(first int) RootOperationTypeDefinitionList {
	nodeList := RootOperationTypeDefinitionList{}
	nodeList.SetFirst(first)
	return nodeList
}

func (n *RootOperationTypeDefinitionList) SetFirst(first int) {
	n.nextRef = first
	n.isInitialized = first != -1
}

func (n *RootOperationTypeDefinitionList) HasNext() bool {
	return n.isInitialized && n.nextRef != -1
}

func (n *RootOperationTypeDefinitionList) Next(getter RootOperationTypeDefinitionGetter) bool {
	if !n.isInitialized || n.nextRef == -1 {
		return false
	}
	n.currentRef = n.nextRef
	n.current, n.nextRef = getter.GetRootOperationTypeDefinition(n.nextRef)
	return true
}

func (n *RootOperationTypeDefinitionList) Value() (RootOperationTypeDefinition, int) {
	return n.current, n.currentRef
}

type ArgumentList struct {
	Open          position.Position
	Close         position.Position
	current       Argument
	currentRef    int
	nextRef       int
	isInitialized bool
}

type ArgumentGetter interface {
	GetArgument(ref int) (node Argument, nextRef int)
}

func NewArgumentList(first int) ArgumentList {
	nodeList := ArgumentList{}
	nodeList.SetFirst(first)
	return nodeList
}

func (n *ArgumentList) SetFirst(first int) {
	n.nextRef = first
	n.isInitialized = first != -1
}

func (n *ArgumentList) HasNext() bool {
	return n.isInitialized && n.nextRef != -1
}

func (n *ArgumentList) Next(getter ArgumentGetter) bool {
	if !n.isInitialized || n.nextRef == -1 {
		return false
	}
	n.currentRef = n.nextRef
	n.current, n.nextRef = getter.GetArgument(n.nextRef)
	return true
}

func (n *ArgumentList) Value() (Argument, int) {
	return n.current, n.currentRef
}

type NamedTypeList struct {
	Open          position.Position
	Close         position.Position
	current       NamedType
	currentRef    int
	nextRef       int
	isInitialized bool
}

type NamedTypeGetter interface {
	GetNamedType(ref int) (node NamedType, nextRef int)
}

func NewNamedTypeList(first int) NamedTypeList {
	nodeList := NamedTypeList{}
	nodeList.SetFirst(first)
	return nodeList
}

func (n *NamedTypeList) SetFirst(first int) {
	n.nextRef = first
	n.isInitialized = first != -1
}

func (n *NamedTypeList) HasNext() bool {
	return n.isInitialized && n.nextRef != -1
}

func (n *NamedTypeList) Next(getter NamedTypeGetter) bool {
	if !n.isInitialized || n.nextRef == -1 {
		return false
	}
	n.currentRef = n.nextRef
	n.current, n.nextRef = getter.GetNamedType(n.nextRef)
	return true
}

func (n *NamedTypeList) Value() (NamedType, int) {
	return n.current, n.currentRef
}

type InputValueDefinitionList struct {
	Open          position.Position
	Close         position.Position
	current       InputValueDefinition
	currentRef    int
	nextRef       int
	isInitialized bool
}

type InputValueDefinitionGetter interface {
	GetInputValueDefinition(ref int) (node InputValueDefinition, nextRef int)
}

func NewInputValueDefinitionList(first int) InputValueDefinitionList {
	nodeList := InputValueDefinitionList{}
	nodeList.SetFirst(first)
	return nodeList
}

func (n *InputValueDefinitionList) SetFirst(first int) {
	n.nextRef = first
	n.isInitialized = first != -1
}

func (n *InputValueDefinitionList) HasNext() bool {
	return n.isInitialized && n.nextRef != -1
}

func (n *InputValueDefinitionList) Next(getter InputValueDefinitionGetter) bool {
	if !n.isInitialized || n.nextRef == -1 {
		return false
	}
	n.currentRef = n.nextRef
	n.current, n.nextRef = getter.GetInputValueDefinition(n.nextRef)
	return true
}

func (n *InputValueDefinitionList) Value() (InputValueDefinition, int) {
	return n.current, n.currentRef
}
